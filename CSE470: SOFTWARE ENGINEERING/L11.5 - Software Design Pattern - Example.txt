CSE 470
Software Engineering
Software Design Patterns
Imran Zahid
Lecturer
Computer Science and Engineering, BRAC University

Example

Scenario
SmartLiving Inc. requires a centralized smart home control system that can manage both modern smart devices and legacy systems. The system must maintain a single control point for all devices, support real-time status updates, and ensure consistent state management across the entire network of connected devices. The initial implementation should support smart lights, thermostats, and security systems through a command-line interface.

Scenario
The system must be designed to prevent control conflicts through centralized management (Singleton), support dynamic device registration with real-time updates to all connected devices (Observer), and seamlessly integrate existing legacy security systems without requiring their replacement (Adapter).

Singleton Pattern – Centralized Controller
Decision: To avoid control conflicts and ensure consistent state management, only one instance of the Smart Home Controller should exist.
Implementation: The Singleton Pattern is used in the SmartHomeController class.
The private class variable _instance and the overridden __new__ method ensure that all device registrations and notifications go through a single control point.
Outcome: This guarantees that device states are managed consistently across the entire system.

Observer Pattern – Managing Device Updates
Decision: Devices in the system need to receive real-time updates and react to state changes issued by the controller.
Implementation: The Observer Pattern is implemented with an abstract class SmartDevice that declares the update and get_name methods.
Concrete devices, such as SmartLight and SmartThermostat, implement this interface and subscribe to the controller.
Outcome: When the controller changes state, it automatically notifies all registered devices, ensuring synchronized behavior across the system.

Adapter Pattern – Integrating Legacy Systems
Decision: Legacy alarm systems use an incompatible interface but must be integrated without complete replacement.
Implementation: The Adapter Pattern is exemplified by the AlarmSystemAdapter class, which wraps the LegacyAlarmSystem.
The adapter translates updates from the controller into calls that the legacy system understands (e.g., arming and disarming).
Outcome:The system treats legacy devices as smart devices with a consistent interface, enabling seamless integration into the control framework.

Thank you
